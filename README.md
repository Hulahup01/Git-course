# Git

## [1] Система контроля версий

> **Система контроля версий (СКВ)**  —  это система, записывающая изменения в файл или набор файлов в течение времени и позволяющая вернуться позже к определённой версии.

Виды СКВ:
- Локальная СКВ;
- Централизованная СКВ;
- Распределённая СКВ;

> **Git** — система управления версиями с распределенной архитектурой.

В отличие от некогда популярных систем вроде CVS и Subversion (SVN), где полная история версий проекта доступна лишь в одном месте, в Git каждая рабочая копия кода сама по себе является репозиторием. Это позволяет всем разработчикам хранить историю изменений в полном объеме.


*Подробнее:* [Система контроля версий](https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%9E-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8F-%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B9)

## [2] Состояния файла

 У Git есть три основных состояния, в которых могут находиться ваши файлы:
 - изменён (modified) -  файлы, которые поменялись, но ещё не были зафиксированы; 
 - индексирован (staged) - изменённый файл в его текущей версии, отмеченный для включения в следующий коммит;
 - зафиксирован (committed) - файл уже сохранён в вашей локальной базе.

*Подробнее:* [Состояния файла](https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-Git%3F#:~:text=%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8%20%D0%BE%D1%82%D0%BC%D0%B5%D0%BD%D1%8B.-,%D0%A2%D1%80%D0%B8%20%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F,-%D0%A2%D0%B5%D0%BF%D0%B5%D1%80%D1%8C%20%D1%81%D0%BB%D1%83%D1%88%D0%B0%D0%B9%D1%82%D0%B5%20%D0%B2%D0%BD%D0%B8%D0%BC%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE)

## [3] Создание репозитория

Если у вас уже есть проект в каталоге, который не находится под версионным контролем Git, то для начала нужно перейти в него. Если вы не делали этого раньше, то для разных операционных систем это выглядит по-разному:


для Linux: `$ cd /home/user/my_project`

для macOS: `$ cd /Users/user/my_project`

для Windows: `$ cd C:/Users/user/my_project`

а затем выполните команду: `$ git init`

*Подробнее:* [Создание репозитория](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-Git-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F) 


## [4] Клонирование репозитория

Клонирование репозитория осуществляется командой: `git clone <url>`. Например, если вы хотите клонировать библиотеку `libgit2`, вы можете сделать это следующим образом:

`$ git clone https://github.com/libgit2/libgit2`

Эта команда создаёт каталог `libgit2`, инициализирует в нём подкаталог `.git`, скачивает все данные для этого репозитория и извлекает рабочую копию последней версии. Если вы перейдёте в только что созданный каталог `libgit2`, то увидите в нём файлы проекта, готовые для работы или использования.

Для того, чтобы клонировать репозиторий в каталог с именем, отличающимся от `libgit2`, необходимо указать желаемое имя, как параметр командной строки:

`$ git clone https://github.com/libgit2/libgit2 mylibgit`

*Подробнее:* [Клонирование репозитория](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-Git-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F#r_git_cloning)


## [5] Запись изменений в репозиторий

Каждый файл в рабочем каталоге может находиться в одном из двух состояний: *под версионным контролем (отслеживаемые)* и *нет (неотслеживаемые)*.

> **Отслеживаемые файлы** — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту. Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.

> **Неотслеживаемые файлы**  — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту.

 Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек и вы ничего пока не редактировали.

 Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, так как вы изменили их с момента последнего коммита. Вы индексируете эти изменения, затем фиксируете все проиндексированные изменения, а затем цикл повторяется.

`git status` - основной инструмент, используемый для определения, какие файлы в каком состоянии находятся.

`git add` - начать отслеживать (добавить под версионный контроль) новый файл.

Если результат работы команды git status недостаточно информативен для вас — вам хочется знать, что конкретно поменялось, а не только какие файлы были изменены — вы можете использовать команду `git diff`. 

Kогда ваш индекс находится в таком состоянии, как вам и хотелось, вы можете зафиксировать свои изменения. Простейший способ зафиксировать изменения  — `git commit`.

Команда `git stash` позволяет на время «сдать в архив» (или *отложить*) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже. Откладывание изменений полезно, если вам необходимо переключить контекст и вы пока не готовы к созданию коммита.

Чтобы применить ранее отложенные изменения, воспользуйтесь командой `git stash pop.` При *извлечении* отложенных изменений они удаляются из набора и применяются к рабочей копии. Вы также можете применить изменения к рабочей копии, *не* удаляя их из набора отложенных изменений. Для этого воспользуйтесь командой `git stash apply`.

*Подробнее:* [Запись изменений в репозиторий](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D1%8C-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B2-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B9)

## [6] Просмотр истории коммитов

После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, чтобы просмотреть что было сделано  —  историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда `git log`.

*Подробнее:* [Просмотр истории коммитов](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2)


## [7] Операции отмены

Если вы хотите переделать коммит — внесите необходимые изменения, добавьте их в индекс и сделайте коммит ещё раз, указав параметр `--amend`:

`$ git commit --amend`

Эта команда использует область подготовки (индекс) для внесения правок в коммит. Если вы ничего не меняли с момента последнего коммита (например, команда запущена сразу после предыдущего коммита), то снимок состояния останется в точности таким же, а всё что вы сможете изменить — это ваше сообщение к коммиту.

Например, если вы сделали коммит и поняли, что забыли проиндексировать изменения в файле, который хотели добавить в коммит, то можно сделать следующее:

```js
$ git commit -m 'Initial commit'
$ git add forgotten_file
$ git commit --amend
```

В итоге получится единый коммит — второй коммит заменит результаты первого.

### Отмена последнего коммита

Отменить последний коммит можно также при помощи команды **git reset.** Но будьте осторожны: это изменит историю коммитов.

Флаги git reset:

- `git reset --soft`   позволяет сохранить незакоммиченные изменения (если они были) как staged;
- `git reset --hard` позволяет сбросить все до последнего коммита, а также удалить все неподготовленные изменения;
- `git reset --mixed` режим работы по умолчанию. Указатели ссылок обновляются. Раздел проиндексированных файлов сбрасывается до состояния указанного коммита. Любые изменения, которые были отменены в разделе проиндексированных файлов, перемещаются в рабочий каталог.

*Подробнее:* [Операции отмены](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D0%BE%D1%82%D0%BC%D0%B5%D0%BD%D1%8B)

## [8] Работа с удаленным репозиторием
Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. 

Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее.

`git remote`: просмотреть список настроенных удалённых репозиториев. Команда выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум `origin` - имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование.

`git fetch`: извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали.
Данная команда забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

`git pull` : выполнение этой команды, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

`git push origin master`: отправка вашей ветки master на сервер origin .

*Подробнее:* [Работа с удаленным репозиторием](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%83%D0%B4%D0%B0%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F%D0%BC%D0%B8)

## [9] Ветвление в git
> **Ветка** в Git — это легковесный подвижный указатель на один из коммитов. Ветка по-умолчанию в Git называется `master`. Когда вы создаёте коммиты на начальном этапе, вам дана ветка `master`, указывающая на последний сделанный коммит. При каждом новом коммите она сдвигается вперёд автоматически.

**Ветвление** означает, что вы отклоняетесь от основной линии разработки и продолжаете работу, не вмешиваясь в основную линию.

Создадим новую ветку под названием `testing`. Это делается командой `git branch`:

```js
git branch testing
```

Чтобы перейти на существующую ветку, вам надо выполнить команду `git checkout`. Перейдём на новую ветку `testing`:

```js
git checkout testing
```

Есть возможность создать новую ветку и сразу же на нее переключиться. Создадим и переключимся на ветку `testing`
```js
`git checkout -b testing`
```

`git merge` выполнит слияние отдельных направлений разработки, созданных с помощью команды `git branch`, в единую ветку.

*Подробнее:* [Ветвление в git](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F)

## [10] Перебазирование
> **Rebase (перебазирование)** — один из способов в git, позволяющий объединить изменения двух веток. У этого способа есть преимущество перед merge (слияние) — он позволяет переписать историю ветки, придав тот истории тот вид, который нам нужен.

Например, у нас есть две ветки — `master` и `my_branch`. Мы находимся на ветке `my_branch (HEAD указывает на ветку my_branch). Выполняем команду:

```js
git rebase master
```

После этого git удалит и последовательно переместит все коммиты из ветки `my_branch` в ветку `master`. Новые коммиты будут полностью идентичны удаленным, меняется только хеш.

*Подробнее:* [Перебазирование](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9F%D0%B5%D1%80%D0%B5%D0%B1%D0%B0%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)